// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientInfo.proto

#ifndef PROTOBUF_ClientInfo_2eproto__INCLUDED
#define PROTOBUF_ClientInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace sqage {
namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientInfo_2eproto();
void protobuf_AssignDesc_ClientInfo_2eproto();
void protobuf_ShutdownFile_ClientInfo_2eproto();

class ClientInfo;

// ===================================================================

class ClientInfo : public ::google::protobuf::Message {
 public:
  ClientInfo();
  virtual ~ClientInfo();

  ClientInfo(const ClientInfo& from);

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientInfo& default_instance();

  void Swap(ClientInfo* other);

  // implements Message ----------------------------------------------

  ClientInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userType = 1;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUserTypeFieldNumber = 1;
  inline const ::std::string& usertype() const;
  inline void set_usertype(const ::std::string& value);
  inline void set_usertype(const char* value);
  inline void set_usertype(const char* value, size_t size);
  inline ::std::string* mutable_usertype();
  inline ::std::string* release_usertype();
  inline void set_allocated_usertype(::std::string* usertype);

  // required string clientId = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 2;
  inline const ::std::string& clientid() const;
  inline void set_clientid(const ::std::string& value);
  inline void set_clientid(const char* value);
  inline void set_clientid(const char* value, size_t size);
  inline ::std::string* mutable_clientid();
  inline ::std::string* release_clientid();
  inline void set_allocated_clientid(::std::string* clientid);

  // required string channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // required string phoneType = 4;
  inline bool has_phonetype() const;
  inline void clear_phonetype();
  static const int kPhoneTypeFieldNumber = 4;
  inline const ::std::string& phonetype() const;
  inline void set_phonetype(const ::std::string& value);
  inline void set_phonetype(const char* value);
  inline void set_phonetype(const char* value, size_t size);
  inline ::std::string* mutable_phonetype();
  inline ::std::string* release_phonetype();
  inline void set_allocated_phonetype(::std::string* phonetype);

  // required string gpuType = 5;
  inline bool has_gputype() const;
  inline void clear_gputype();
  static const int kGpuTypeFieldNumber = 5;
  inline const ::std::string& gputype() const;
  inline void set_gputype(const ::std::string& value);
  inline void set_gputype(const char* value);
  inline void set_gputype(const char* value, size_t size);
  inline ::std::string* mutable_gputype();
  inline ::std::string* release_gputype();
  inline void set_allocated_gputype(::std::string* gputype);

  // required string networkMode = 6;
  inline bool has_networkmode() const;
  inline void clear_networkmode();
  static const int kNetworkModeFieldNumber = 6;
  inline const ::std::string& networkmode() const;
  inline void set_networkmode(const ::std::string& value);
  inline void set_networkmode(const char* value);
  inline void set_networkmode(const char* value, size_t size);
  inline ::std::string* mutable_networkmode();
  inline ::std::string* release_networkmode();
  inline void set_allocated_networkmode(::std::string* networkmode);

  // required string resourceVersion = 7;
  inline bool has_resourceversion() const;
  inline void clear_resourceversion();
  static const int kResourceVersionFieldNumber = 7;
  inline const ::std::string& resourceversion() const;
  inline void set_resourceversion(const ::std::string& value);
  inline void set_resourceversion(const char* value);
  inline void set_resourceversion(const char* value, size_t size);
  inline ::std::string* mutable_resourceversion();
  inline ::std::string* release_resourceversion();
  inline void set_allocated_resourceversion(::std::string* resourceversion);

  // required string programVersion = 8;
  inline bool has_programversion() const;
  inline void clear_programversion();
  static const int kProgramVersionFieldNumber = 8;
  inline const ::std::string& programversion() const;
  inline void set_programversion(const ::std::string& value);
  inline void set_programversion(const char* value);
  inline void set_programversion(const char* value, size_t size);
  inline ::std::string* mutable_programversion();
  inline ::std::string* release_programversion();
  inline void set_allocated_programversion(::std::string* programversion);

  // repeated string otherInfo = 9;
  inline int otherinfo_size() const;
  inline void clear_otherinfo();
  static const int kOtherInfoFieldNumber = 9;
  inline const ::std::string& otherinfo(int index) const;
  inline ::std::string* mutable_otherinfo(int index);
  inline void set_otherinfo(int index, const ::std::string& value);
  inline void set_otherinfo(int index, const char* value);
  inline void set_otherinfo(int index, const char* value, size_t size);
  inline ::std::string* add_otherinfo();
  inline void add_otherinfo(const ::std::string& value);
  inline void add_otherinfo(const char* value);
  inline void add_otherinfo(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& otherinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_otherinfo();

  // required string mac = 10;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 10;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string idfa = 11;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 11;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional string androidId = 12;
  inline bool has_androidid() const;
  inline void clear_androidid();
  static const int kAndroidIdFieldNumber = 12;
  inline const ::std::string& androidid() const;
  inline void set_androidid(const ::std::string& value);
  inline void set_androidid(const char* value);
  inline void set_androidid(const char* value, size_t size);
  inline ::std::string* mutable_androidid();
  inline ::std::string* release_androidid();
  inline void set_allocated_androidid(::std::string* androidid);

  // @@protoc_insertion_point(class_scope:com.sqage.client.ClientInfo)
 private:
  inline void set_has_usertype();
  inline void clear_has_usertype();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_phonetype();
  inline void clear_has_phonetype();
  inline void set_has_gputype();
  inline void clear_has_gputype();
  inline void set_has_networkmode();
  inline void clear_has_networkmode();
  inline void set_has_resourceversion();
  inline void clear_has_resourceversion();
  inline void set_has_programversion();
  inline void clear_has_programversion();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_androidid();
  inline void clear_has_androidid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* usertype_;
  ::std::string* clientid_;
  ::std::string* channel_;
  ::std::string* phonetype_;
  ::std::string* gputype_;
  ::std::string* networkmode_;
  ::std::string* resourceversion_;
  ::std::string* programversion_;
  ::google::protobuf::RepeatedPtrField< ::std::string> otherinfo_;
  ::std::string* mac_;
  ::std::string* idfa_;
  ::std::string* androidid_;
  friend void  protobuf_AddDesc_ClientInfo_2eproto();
  friend void protobuf_AssignDesc_ClientInfo_2eproto();
  friend void protobuf_ShutdownFile_ClientInfo_2eproto();

  void InitAsDefaultInstance();
  static ClientInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientInfo

// required string userType = 1;
inline bool ClientInfo::has_usertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInfo::set_has_usertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientInfo::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientInfo::clear_usertype() {
  if (usertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usertype_->clear();
  }
  clear_has_usertype();
}
inline const ::std::string& ClientInfo::usertype() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.userType)
  return *usertype_;
}
inline void ClientInfo::set_usertype(const ::std::string& value) {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usertype_ = new ::std::string;
  }
  usertype_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.userType)
}
inline void ClientInfo::set_usertype(const char* value) {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usertype_ = new ::std::string;
  }
  usertype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.userType)
}
inline void ClientInfo::set_usertype(const char* value, size_t size) {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usertype_ = new ::std::string;
  }
  usertype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.userType)
}
inline ::std::string* ClientInfo::mutable_usertype() {
  set_has_usertype();
  if (usertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usertype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.userType)
  return usertype_;
}
inline ::std::string* ClientInfo::release_usertype() {
  clear_has_usertype();
  if (usertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usertype_;
    usertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_usertype(::std::string* usertype) {
  if (usertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usertype_;
  }
  if (usertype) {
    set_has_usertype();
    usertype_ = usertype;
  } else {
    clear_has_usertype();
    usertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.userType)
}

// required string clientId = 2;
inline bool ClientInfo::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInfo::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientInfo::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientInfo::clear_clientid() {
  if (clientid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_->clear();
  }
  clear_has_clientid();
}
inline const ::std::string& ClientInfo::clientid() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.clientId)
  return *clientid_;
}
inline void ClientInfo::set_clientid(const ::std::string& value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.clientId)
}
inline void ClientInfo::set_clientid(const char* value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.clientId)
}
inline void ClientInfo::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.clientId)
}
inline ::std::string* ClientInfo::mutable_clientid() {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.clientId)
  return clientid_;
}
inline ::std::string* ClientInfo::release_clientid() {
  clear_has_clientid();
  if (clientid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientid_;
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_clientid(::std::string* clientid) {
  if (clientid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientid_;
  }
  if (clientid) {
    set_has_clientid();
    clientid_ = clientid;
  } else {
    clear_has_clientid();
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.clientId)
}

// required string channel = 3;
inline bool ClientInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientInfo::clear_channel() {
  if (channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& ClientInfo::channel() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.channel)
  return *channel_;
}
inline void ClientInfo::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.channel)
}
inline void ClientInfo::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.channel)
}
inline void ClientInfo::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.channel)
}
inline ::std::string* ClientInfo::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.channel)
  return channel_;
}
inline ::std::string* ClientInfo::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.channel)
}

// required string phoneType = 4;
inline bool ClientInfo::has_phonetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientInfo::set_has_phonetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientInfo::clear_has_phonetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientInfo::clear_phonetype() {
  if (phonetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_->clear();
  }
  clear_has_phonetype();
}
inline const ::std::string& ClientInfo::phonetype() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.phoneType)
  return *phonetype_;
}
inline void ClientInfo::set_phonetype(const ::std::string& value) {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  phonetype_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.phoneType)
}
inline void ClientInfo::set_phonetype(const char* value) {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  phonetype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.phoneType)
}
inline void ClientInfo::set_phonetype(const char* value, size_t size) {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  phonetype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.phoneType)
}
inline ::std::string* ClientInfo::mutable_phonetype() {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.phoneType)
  return phonetype_;
}
inline ::std::string* ClientInfo::release_phonetype() {
  clear_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonetype_;
    phonetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_phonetype(::std::string* phonetype) {
  if (phonetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonetype_;
  }
  if (phonetype) {
    set_has_phonetype();
    phonetype_ = phonetype;
  } else {
    clear_has_phonetype();
    phonetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.phoneType)
}

// required string gpuType = 5;
inline bool ClientInfo::has_gputype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientInfo::set_has_gputype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientInfo::clear_has_gputype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientInfo::clear_gputype() {
  if (gputype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gputype_->clear();
  }
  clear_has_gputype();
}
inline const ::std::string& ClientInfo::gputype() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.gpuType)
  return *gputype_;
}
inline void ClientInfo::set_gputype(const ::std::string& value) {
  set_has_gputype();
  if (gputype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gputype_ = new ::std::string;
  }
  gputype_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.gpuType)
}
inline void ClientInfo::set_gputype(const char* value) {
  set_has_gputype();
  if (gputype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gputype_ = new ::std::string;
  }
  gputype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.gpuType)
}
inline void ClientInfo::set_gputype(const char* value, size_t size) {
  set_has_gputype();
  if (gputype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gputype_ = new ::std::string;
  }
  gputype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.gpuType)
}
inline ::std::string* ClientInfo::mutable_gputype() {
  set_has_gputype();
  if (gputype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gputype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.gpuType)
  return gputype_;
}
inline ::std::string* ClientInfo::release_gputype() {
  clear_has_gputype();
  if (gputype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gputype_;
    gputype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_gputype(::std::string* gputype) {
  if (gputype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gputype_;
  }
  if (gputype) {
    set_has_gputype();
    gputype_ = gputype;
  } else {
    clear_has_gputype();
    gputype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.gpuType)
}

// required string networkMode = 6;
inline bool ClientInfo::has_networkmode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientInfo::set_has_networkmode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientInfo::clear_has_networkmode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientInfo::clear_networkmode() {
  if (networkmode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    networkmode_->clear();
  }
  clear_has_networkmode();
}
inline const ::std::string& ClientInfo::networkmode() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.networkMode)
  return *networkmode_;
}
inline void ClientInfo::set_networkmode(const ::std::string& value) {
  set_has_networkmode();
  if (networkmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    networkmode_ = new ::std::string;
  }
  networkmode_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.networkMode)
}
inline void ClientInfo::set_networkmode(const char* value) {
  set_has_networkmode();
  if (networkmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    networkmode_ = new ::std::string;
  }
  networkmode_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.networkMode)
}
inline void ClientInfo::set_networkmode(const char* value, size_t size) {
  set_has_networkmode();
  if (networkmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    networkmode_ = new ::std::string;
  }
  networkmode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.networkMode)
}
inline ::std::string* ClientInfo::mutable_networkmode() {
  set_has_networkmode();
  if (networkmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    networkmode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.networkMode)
  return networkmode_;
}
inline ::std::string* ClientInfo::release_networkmode() {
  clear_has_networkmode();
  if (networkmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = networkmode_;
    networkmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_networkmode(::std::string* networkmode) {
  if (networkmode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete networkmode_;
  }
  if (networkmode) {
    set_has_networkmode();
    networkmode_ = networkmode;
  } else {
    clear_has_networkmode();
    networkmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.networkMode)
}

// required string resourceVersion = 7;
inline bool ClientInfo::has_resourceversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientInfo::set_has_resourceversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientInfo::clear_has_resourceversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientInfo::clear_resourceversion() {
  if (resourceversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourceversion_->clear();
  }
  clear_has_resourceversion();
}
inline const ::std::string& ClientInfo::resourceversion() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.resourceVersion)
  return *resourceversion_;
}
inline void ClientInfo::set_resourceversion(const ::std::string& value) {
  set_has_resourceversion();
  if (resourceversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourceversion_ = new ::std::string;
  }
  resourceversion_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.resourceVersion)
}
inline void ClientInfo::set_resourceversion(const char* value) {
  set_has_resourceversion();
  if (resourceversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourceversion_ = new ::std::string;
  }
  resourceversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.resourceVersion)
}
inline void ClientInfo::set_resourceversion(const char* value, size_t size) {
  set_has_resourceversion();
  if (resourceversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourceversion_ = new ::std::string;
  }
  resourceversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.resourceVersion)
}
inline ::std::string* ClientInfo::mutable_resourceversion() {
  set_has_resourceversion();
  if (resourceversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourceversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.resourceVersion)
  return resourceversion_;
}
inline ::std::string* ClientInfo::release_resourceversion() {
  clear_has_resourceversion();
  if (resourceversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resourceversion_;
    resourceversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_resourceversion(::std::string* resourceversion) {
  if (resourceversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resourceversion_;
  }
  if (resourceversion) {
    set_has_resourceversion();
    resourceversion_ = resourceversion;
  } else {
    clear_has_resourceversion();
    resourceversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.resourceVersion)
}

// required string programVersion = 8;
inline bool ClientInfo::has_programversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientInfo::set_has_programversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientInfo::clear_has_programversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientInfo::clear_programversion() {
  if (programversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    programversion_->clear();
  }
  clear_has_programversion();
}
inline const ::std::string& ClientInfo::programversion() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.programVersion)
  return *programversion_;
}
inline void ClientInfo::set_programversion(const ::std::string& value) {
  set_has_programversion();
  if (programversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    programversion_ = new ::std::string;
  }
  programversion_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.programVersion)
}
inline void ClientInfo::set_programversion(const char* value) {
  set_has_programversion();
  if (programversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    programversion_ = new ::std::string;
  }
  programversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.programVersion)
}
inline void ClientInfo::set_programversion(const char* value, size_t size) {
  set_has_programversion();
  if (programversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    programversion_ = new ::std::string;
  }
  programversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.programVersion)
}
inline ::std::string* ClientInfo::mutable_programversion() {
  set_has_programversion();
  if (programversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    programversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.programVersion)
  return programversion_;
}
inline ::std::string* ClientInfo::release_programversion() {
  clear_has_programversion();
  if (programversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = programversion_;
    programversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_programversion(::std::string* programversion) {
  if (programversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete programversion_;
  }
  if (programversion) {
    set_has_programversion();
    programversion_ = programversion;
  } else {
    clear_has_programversion();
    programversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.programVersion)
}

// repeated string otherInfo = 9;
inline int ClientInfo::otherinfo_size() const {
  return otherinfo_.size();
}
inline void ClientInfo::clear_otherinfo() {
  otherinfo_.Clear();
}
inline const ::std::string& ClientInfo::otherinfo(int index) const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.otherInfo)
  return otherinfo_.Get(index);
}
inline ::std::string* ClientInfo::mutable_otherinfo(int index) {
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.otherInfo)
  return otherinfo_.Mutable(index);
}
inline void ClientInfo::set_otherinfo(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.otherInfo)
  otherinfo_.Mutable(index)->assign(value);
}
inline void ClientInfo::set_otherinfo(int index, const char* value) {
  otherinfo_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.otherInfo)
}
inline void ClientInfo::set_otherinfo(int index, const char* value, size_t size) {
  otherinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.otherInfo)
}
inline ::std::string* ClientInfo::add_otherinfo() {
  return otherinfo_.Add();
}
inline void ClientInfo::add_otherinfo(const ::std::string& value) {
  otherinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.sqage.client.ClientInfo.otherInfo)
}
inline void ClientInfo::add_otherinfo(const char* value) {
  otherinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.sqage.client.ClientInfo.otherInfo)
}
inline void ClientInfo::add_otherinfo(const char* value, size_t size) {
  otherinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.sqage.client.ClientInfo.otherInfo)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientInfo::otherinfo() const {
  // @@protoc_insertion_point(field_list:com.sqage.client.ClientInfo.otherInfo)
  return otherinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientInfo::mutable_otherinfo() {
  // @@protoc_insertion_point(field_mutable_list:com.sqage.client.ClientInfo.otherInfo)
  return &otherinfo_;
}

// required string mac = 10;
inline bool ClientInfo::has_mac() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientInfo::set_has_mac() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientInfo::clear_has_mac() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientInfo::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& ClientInfo::mac() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.mac)
  return *mac_;
}
inline void ClientInfo::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.mac)
}
inline void ClientInfo::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.mac)
}
inline void ClientInfo::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.mac)
}
inline ::std::string* ClientInfo::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.mac)
  return mac_;
}
inline ::std::string* ClientInfo::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.mac)
}

// optional string idfa = 11;
inline bool ClientInfo::has_idfa() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientInfo::set_has_idfa() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientInfo::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientInfo::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& ClientInfo::idfa() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.idfa)
  return *idfa_;
}
inline void ClientInfo::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.idfa)
}
inline void ClientInfo::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.idfa)
}
inline void ClientInfo::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.idfa)
}
inline ::std::string* ClientInfo::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.idfa)
  return idfa_;
}
inline ::std::string* ClientInfo::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.idfa)
}

// optional string androidId = 12;
inline bool ClientInfo::has_androidid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientInfo::set_has_androidid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientInfo::clear_has_androidid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientInfo::clear_androidid() {
  if (androidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_->clear();
  }
  clear_has_androidid();
}
inline const ::std::string& ClientInfo::androidid() const {
  // @@protoc_insertion_point(field_get:com.sqage.client.ClientInfo.androidId)
  return *androidid_;
}
inline void ClientInfo::set_androidid(const ::std::string& value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
  // @@protoc_insertion_point(field_set:com.sqage.client.ClientInfo.androidId)
}
inline void ClientInfo::set_androidid(const char* value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.sqage.client.ClientInfo.androidId)
}
inline void ClientInfo::set_androidid(const char* value, size_t size) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.sqage.client.ClientInfo.androidId)
}
inline ::std::string* ClientInfo::mutable_androidid() {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.sqage.client.ClientInfo.androidId)
  return androidid_;
}
inline ::std::string* ClientInfo::release_androidid() {
  clear_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = androidid_;
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_androidid(::std::string* androidid) {
  if (androidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete androidid_;
  }
  if (androidid) {
    set_has_androidid();
    androidid_ = androidid;
  } else {
    clear_has_androidid();
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.sqage.client.ClientInfo.androidId)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client
}  // namespace sqage
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClientInfo_2eproto__INCLUDED
